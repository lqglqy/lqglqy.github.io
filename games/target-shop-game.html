<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pop Targets! (Local HTML Game)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b1020; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #wrap { display:flex; flex-direction:column; height:100%; }
    #topbar {
      display:flex; flex-wrap:wrap; gap:12px; align-items:center;
      padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.12);
      background: rgba(10,16,32,.85);
    }
    .pill { padding:6px 10px; border:1px solid rgba(255,255,255,.15); border-radius:999px; background: rgba(255,255,255,.04); }
    .btn {
      cursor:pointer; user-select:none; border-radius:10px; padding:8px 10px;
      border:1px solid rgba(255,255,255,.18); background: rgba(255,255,255,.06);
    }
    .btn:hover { background: rgba(255,255,255,.10); }
    .btn:active { transform: translateY(1px); }
    #main { flex:1; display:grid; grid-template-columns: 1fr 320px; gap:0; min-height:0; }
    #game { width: 100%; height: 100%; display:block; background: radial-gradient(1200px 600px at 30% 20%, #1b2a55 0%, #0b1020 55%, #070b16 100%); }
    #side {
      border-left:1px solid rgba(255,255,255,.12);
      background: rgba(10,16,32,.75);
      padding:12px;
      overflow:auto;
    }
    h2 { margin: 8px 0 10px; font-size:16px; }
    .shopItem { display:flex; gap:10px; align-items:flex-start; padding:10px; border:1px solid rgba(255,255,255,.12); border-radius:12px; background: rgba(255,255,255,.04); margin-bottom:10px; }
    .shopItem strong { display:block; font-size:14px; margin-bottom:4px; }
    .shopItem small { display:block; opacity:.85; line-height:1.25; }
    .shopItem .buy { margin-left:auto; white-space:nowrap; }
    .muted { opacity: .8; }
    kbd { border:1px solid rgba(255,255,255,.18); background: rgba(255,255,255,.06); padding:2px 6px; border-radius:8px; font-size:12px; }
    #toast {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 14px; padding: 10px 12px;
      background: rgba(0,0,0,.6); border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px; opacity: 0; pointer-events:none; transition: opacity .18s;
    }
    #toast.show { opacity: 1; }
    @media (max-width: 980px) {
      #main { grid-template-columns: 1fr; }
      #side { border-left:none; border-top:1px solid rgba(255,255,255,.12); }
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Coins: <span id="coins">0</span></div>
    <div class="pill">Wave: <span id="wave">1</span></div>
    <div class="pill">HP: <span id="hp">5</span></div>
    <div class="pill">Gun: <span id="gunName">Pea Popper</span></div>
    <div class="pill muted">Aim: mouse · Shoot: <kbd>click</kbd>/<kbd>space</kbd> · Reload: <kbd>R</kbd> · Shop: <kbd>B</kbd> · Pause: <kbd>P</kbd></div>
    <div class="btn" id="resetBtn">Reset</div>
  </div>

  <div id="main">
    <canvas id="game"></canvas>
    <div id="side">
      <h2>Shop (press <kbd>B</kbd>)</h2>
      <div class="muted" style="margin-bottom:10px; line-height:1.3">
        Shoot targets for coins. Miss too much and you lose HP. When HP hits 0, game over.
        Buying upgrades makes your cartoony gun go brrrr.
      </div>

      <div id="shop">
        <!-- items injected -->
      </div>

      <h2>Tips</h2>
      <ul class="muted" style="padding-left:18px; line-height:1.35">
        <li>Some targets move; some are armored.</li>
        <li>Coins come from hits; more coins for tougher targets.</li>
        <li>Try buying <b>Fire Rate</b> early, then <b>Damage</b>.</li>
      </ul>

      <h2>Difficulty</h2>
      <div class="muted">Wave increases spawn rate & target speed.</div>
    </div>
  </div>
</div>
<div id="toast"></div>

<script>
(() => {
  // --- Canvas setup ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const coinsEl = document.getElementById('coins');
  const waveEl = document.getElementById('wave');
  const hpEl = document.getElementById('hp');
  const gunNameEl = document.getElementById('gunName');
  const shopEl = document.getElementById('shop');
  const toastEl = document.getElementById('toast');

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  // --- Game state ---
  const state = {
    running: true,
    paused: false,
    gameOver: false,
    t: 0,
    score: 0,
    coins: 0,
    wave: 1,
    hp: 5,
    aim: { x: 100, y: 100 },
    shake: 0,
    lastShotAt: 0,
    reloadAt: 0,
    ammo: 12,
    maxAmmo: 12,
    reloadMs: 900,
    // gun stats
    gun: {
      name: 'Pea Popper',
      damage: 1,
      bulletSpeed: 900,
      fireDelayMs: 220,
      pellets: 1,
      spread: 0.02,
      critChance: 0.06,
      critMult: 2.0,
    },
    upgrades: {
      fireRate: 0,
      damage: 0,
      mag: 0,
      speed: 0,
      multishot: 0,
      crit: 0,
    }
  };

  const bullets = [];
  const targets = [];
  const particles = [];

  // --- Utility ---
  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

  function toast(msg) {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.classList.remove('show'), 1200);
  }

  function formatCost(n){ return n.toString(); }

  // --- Shop ---
  const shopItems = [
    {
      id: 'fireRate',
      title: 'Fire Rate',
      desc: 'Shoot faster. (Less delay between shots)',
      cost: lvl => 30 + lvl*45,
      apply: () => {
        state.upgrades.fireRate++;
        state.gun.fireDelayMs = Math.max(70, state.gun.fireDelayMs - 20);
        refreshGunName();
      }
    },
    {
      id: 'damage',
      title: 'Damage',
      desc: 'Pop tougher targets in fewer hits.',
      cost: lvl => 35 + lvl*55,
      apply: () => {
        state.upgrades.damage++;
        state.gun.damage += 1;
        refreshGunName();
      }
    },
    {
      id: 'mag',
      title: 'Bigger Magazine',
      desc: 'More ammo before reload.',
      cost: lvl => 25 + lvl*45,
      apply: () => {
        state.upgrades.mag++;
        state.maxAmmo += 3;
        state.ammo = Math.min(state.maxAmmo, state.ammo + 3);
      }
    },
    {
      id: 'speed',
      title: 'Faster Bullets',
      desc: 'Less leading, more hitting.',
      cost: lvl => 20 + lvl*40,
      apply: () => {
        state.upgrades.speed++;
        state.gun.bulletSpeed += 140;
      }
    },
    {
      id: 'multishot',
      title: 'Multishot',
      desc: 'More pellets per shot (shotgun-ish).',
      cost: lvl => 60 + lvl*90,
      apply: () => {
        state.upgrades.multishot++;
        state.gun.pellets = Math.min(7, state.gun.pellets + 1);
        state.gun.spread = Math.min(0.09, state.gun.spread + 0.006);
        refreshGunName();
      }
    },
    {
      id: 'crit',
      title: 'Crit Juice',
      desc: 'Higher crit chance and crit multiplier.',
      cost: lvl => 50 + lvl*75,
      apply: () => {
        state.upgrades.crit++;
        state.gun.critChance = Math.min(0.35, state.gun.critChance + 0.03);
        state.gun.critMult = Math.min(3.0, state.gun.critMult + 0.1);
      }
    },
  ];

  let shopOpen = true;
  const sidePanel = document.getElementById('side');

  function tryBuyIndex(idx) {
    if (!shopOpen) { toast('Press B to open the shop'); return; }
    const item = shopItems[idx];
    if (!item) return;
    const lvl = state.upgrades[item.id] || 0;
    const c = item.cost(lvl);
    if (state.gameOver) return;
    if (state.coins < c) { toast('Not enough coins'); return; }
    state.coins -= c;
    item.apply();
    toast(`Bought ${item.title}`);
    syncUI();
    renderShop();
  }

  function renderShop() {
    shopEl.innerHTML = '';
    shopItems.forEach((item, idx) => {
      const lvl = state.upgrades[item.id] || 0;
      const c = item.cost(lvl);
      const keyHint = idx < 9 ? `<span class="muted">[${idx+1}]</span>` : '';
      const row = document.createElement('div');
      row.className = 'shopItem';
      row.innerHTML = `
        <div>
          <strong>${keyHint} ${item.title} <span class="muted">(Lv ${lvl})</span></strong>
          <small>${item.desc}</small>
          <small class="muted">Cost: <b>${formatCost(c)}</b> coins</small>
        </div>
        <div class="btn buy">Buy</div>
      `;
      row.querySelector('.buy').addEventListener('click', () => tryBuyIndex(idx));
      shopEl.appendChild(row);
    });
  }

  function refreshGunName() {
    const u = state.upgrades;
    let name = 'Pea Popper';
    if (u.multishot >= 2 && u.fireRate >= 3) name = 'Confetti Blaster';
    else if (u.multishot >= 2) name = 'Popcorn Shotty';
    else if (u.fireRate >= 4) name = 'Bubble SMG';
    else if (u.damage >= 4) name = 'Cartoon Cannon';
    state.gun.name = name;
  }

  function syncUI() {
    scoreEl.textContent = state.score;
    coinsEl.textContent = state.coins;
    waveEl.textContent = state.wave;
    hpEl.textContent = state.hp;
    gunNameEl.textContent = state.gun.name;
  }

  // --- Targets ---
  const targetTypes = [
    { name: 'Balloon', r: 16, hp: 1, speed: 60, coin: 2, score: 10, color: '#ff5bd6' },
    { name: 'Can', r: 18, hp: 2, speed: 85, coin: 4, score: 18, color: '#58d2ff' },
    { name: 'Helmet', r: 22, hp: 4, speed: 75, coin: 7, score: 30, color: '#ffd35a' },
    { name: 'UFO', r: 20, hp: 3, speed: 115, coin: 6, score: 26, color: '#8aff7a' },
  ];

  function spawnTarget() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const edge = Math.floor(rand(0,4));
    const type = targetTypes[Math.floor(Math.pow(Math.random(), 1.4) * targetTypes.length)];
    const baseSpeed = type.speed * (1 + (state.wave-1)*0.07);
    let x,y,vx,vy;
    if (edge === 0) { x = -30; y = rand(40, h-40); vx = baseSpeed; vy = rand(-40,40); }
    else if (edge === 1) { x = w+30; y = rand(40, h-40); vx = -baseSpeed; vy = rand(-40,40); }
    else if (edge === 2) { x = rand(40, w-40); y = -30; vx = rand(-50,50); vy = baseSpeed; }
    else { x = rand(40, w-40); y = h+30; vx = rand(-50,50); vy = -baseSpeed; }

    const armor = (type.name === 'Helmet') ? 0.15 : 0;
    targets.push({
      type,
      x,y,vx,vy,
      r: type.r,
      hp: type.hp + Math.floor((state.wave-1)*0.12),
      maxHp: type.hp + Math.floor((state.wave-1)*0.12),
      wobble: rand(0, Math.PI*2),
      armor,
      touched: false,
    });
  }

  // --- Shooting ---
  function canShoot(now) {
    if (!state.running || state.paused || state.gameOver) return false;
    if (now < state.reloadAt) return false;
    if (state.ammo <= 0) return false;
    return (now - state.lastShotAt) >= state.gun.fireDelayMs;
  }

  function shoot(now) {
    if (!canShoot(now)) {
      if (state.ammo <= 0 && now >= state.reloadAt) toast('Out of ammo! Press R');
      return;
    }
    state.lastShotAt = now;
    state.ammo--;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    const origin = { x: w*0.5, y: h*0.86 };
    const dx = state.aim.x - origin.x;
    const dy = state.aim.y - origin.y;
    const baseAng = Math.atan2(dy, dx);

    for (let i=0; i<state.gun.pellets; i++) {
      const ang = baseAng + rand(-state.gun.spread, state.gun.spread);
      const sp = state.gun.bulletSpeed * rand(0.92, 1.05);
      bullets.push({
        x: origin.x,
        y: origin.y,
        vx: Math.cos(ang)*sp,
        vy: Math.sin(ang)*sp,
        r: 4,
        life: 1.35,
      });
    }

    state.shake = Math.min(8, state.shake + 2 + state.gun.pellets*0.12);
    // muzzle particles
    for (let i=0; i<8; i++) {
      particles.push({
        x: origin.x + rand(-6,6), y: origin.y + rand(-6,6),
        vx: rand(-80,80), vy: rand(-120,40),
        r: rand(2,4),
        life: rand(0.18, 0.35),
        color: `hsla(${rand(40,65)},100%,70%,0.95)`
      });
    }
  }

  function reload(now) {
    if (state.gameOver) return;
    if (state.ammo === state.maxAmmo) { toast('Ammo full'); return; }
    state.reloadAt = now + state.reloadMs;
    toast('Reloading…');
    setTimeout(() => {
      if (state.gameOver) return;
      state.ammo = state.maxAmmo;
      toast('Reloaded');
    }, state.reloadMs);
  }

  // --- Input ---
  canvas.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    state.aim.x = e.clientX - r.left;
    state.aim.y = e.clientY - r.top;
  });
  canvas.addEventListener('mousedown', () => shoot(performance.now()));

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); shoot(performance.now()); }
    if (e.key === 'r' || e.key === 'R') reload(performance.now());
    if (e.key === 'p' || e.key === 'P') { state.paused = !state.paused; toast(state.paused ? 'Paused' : 'Unpaused'); }

    // Open/close shop
    if (e.key === 'b' || e.key === 'B') {
      shopOpen = !shopOpen;
      sidePanel.style.display = shopOpen ? 'block' : 'none';
      if (shopOpen) toast('Shop open — press 1-6 to buy');
      return;
    }

    // Quick-buy when shop is open: 1-9
    if (e.key >= '1' && e.key <= '9') {
      tryBuyIndex(parseInt(e.key, 10) - 1);
      return;
    }
  });

  document.getElementById('resetBtn').addEventListener('click', reset);

  // --- Game loop ---
  let last = performance.now();

  function reset() {
    bullets.length = 0;
    targets.length = 0;
    particles.length = 0;
    Object.assign(state, {
      running: true,
      paused: false,
      gameOver: false,
      t: 0,
      score: 0,
      coins: 0,
      wave: 1,
      hp: 5,
      shake: 0,
      lastShotAt: 0,
      reloadAt: 0,
      ammo: 12,
      maxAmmo: 12,
      reloadMs: 900,
      gun: {
        name: 'Pea Popper',
        damage: 1,
        bulletSpeed: 900,
        fireDelayMs: 220,
        pellets: 1,
        spread: 0.02,
        critChance: 0.06,
        critMult: 2.0,
      },
      upgrades: { fireRate:0, damage:0, mag:0, speed:0, multishot:0, crit:0 },
    });
    renderShop();
    syncUI();
    toast('Reset!');
  }

  function setGameOver() {
    state.gameOver = true;
    toast('Game Over — click Reset');
  }

  function update(dt, now) {
    if (!state.running || state.paused) return;
    state.t += dt;

    // Wave progression: every 25 score * wave-ish
    const nextWaveAt = 220 + (state.wave-1)*180;
    if (state.score >= nextWaveAt) {
      state.wave++;
      toast(`Wave ${state.wave}`);
    }

    // Spawn rate increases with wave
    const spawnPerSec = 0.6 + (state.wave-1)*0.14;
    if (Math.random() < spawnPerSec * dt) spawnTarget();

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // bullets
    for (let i=bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.life -= dt;
      if (b.life <= 0 || b.x < -50 || b.x > w+50 || b.y < -50 || b.y > h+50) {
        bullets.splice(i,1);
      }
    }

    // targets
    for (let i=targets.length-1; i>=0; i--) {
      const t = targets[i];
      t.wobble += dt;
      // curvy movement
      const wob = Math.sin(t.wobble*2.2) * 22;
      t.x += (t.vx + wob) * dt;
      t.y += (t.vy + Math.cos(t.wobble*1.7)*18) * dt;

      // bounce in bounds a bit
      if (t.x < 20) t.vx = Math.abs(t.vx);
      if (t.x > w-20) t.vx = -Math.abs(t.vx);
      if (t.y < 20) t.vy = Math.abs(t.vy);
      if (t.y > h-120) t.vy = -Math.abs(t.vy);

      // if reaches "danger zone" near bottom, you lose HP and it escapes
      if (t.y > h-88 && !t.touched) {
        t.touched = true;
        state.hp--;
        state.shake = Math.min(10, state.shake + 5);
        toast('Target escaped! -1 HP');
        // poof
        for (let k=0; k<14; k++) {
          particles.push({ x:t.x, y:t.y, vx:rand(-120,120), vy:rand(-160,40), r:rand(2,5), life:rand(0.25,0.55), color:'rgba(255,80,80,0.9)' });
        }
        targets.splice(i,1);
        if (state.hp <= 0) setGameOver();
      }
    }

    // collisions
    for (let bi=bullets.length-1; bi>=0; bi--) {
      const b = bullets[bi];
      for (let ti=targets.length-1; ti>=0; ti--) {
        const t = targets[ti];
        const dx = t.x - b.x;
        const dy = t.y - b.y;
        const rr = t.r + b.r;
        if (dx*dx + dy*dy <= rr*rr) {
          // hit!
          bullets.splice(bi,1);

          const isCrit = Math.random() < state.gun.critChance;
          let dmg = state.gun.damage;
          if (isCrit) dmg = Math.floor(dmg * state.gun.critMult);
          // armor reduces damage a bit
          dmg = Math.max(1, Math.round(dmg * (1 - t.armor)));

          t.hp -= dmg;
          state.coins += Math.max(1, Math.round(t.type.coin * (isCrit ? 1.4 : 1.0)));
          state.score += Math.max(1, Math.round(t.type.score * (isCrit ? 1.2 : 1.0)));

          // particles
          const col = isCrit ? 'rgba(255,255,255,0.95)' : t.type.color;
          for (let k=0; k<10; k++) {
            particles.push({ x:t.x, y:t.y, vx:rand(-160,160), vy:rand(-160,160), r:rand(2,4), life:rand(0.18,0.45), color:col });
          }

          if (t.hp <= 0) {
            // pop!
            for (let k=0; k<18; k++) {
              particles.push({ x:t.x, y:t.y, vx:rand(-220,220), vy:rand(-220,220), r:rand(2,6), life:rand(0.25,0.6), color:t.type.color });
            }
            targets.splice(ti,1);
          }

          syncUI();
          break;
        }
      }
    }

    // particles
    for (let i=particles.length-1; i>=0; i--) {
      const p = particles[i];
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vy += 300*dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }

    // shop UI occasionally update
    if ((now|0) % 400 < 16) renderShop();
  }

  function draw(now) {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // screen shake
    const s = state.shake;
    const ox = (Math.random()-0.5) * s;
    const oy = (Math.random()-0.5) * s;
    state.shake = Math.max(0, state.shake - 14/60);

    ctx.save();
    ctx.translate(ox, oy);

    // HUD-ish ammo
    ctx.clearRect(-20,-20,w+40,h+40);

    // ground
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0, h*0.88, w, h*0.12);

    // turret / gun
    const origin = { x: w*0.5, y: h*0.86 };
    const ang = Math.atan2(state.aim.y - origin.y, state.aim.x - origin.x);
    // base
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    roundRect(ctx, origin.x-36, origin.y+10, 72, 26, 10);
    ctx.fill();
    // barrel
    ctx.save();
    ctx.translate(origin.x, origin.y);
    ctx.rotate(ang);
    ctx.fillStyle = 'rgba(160,220,255,0.55)';
    roundRect(ctx, 0, -10, 60, 20, 10);
    ctx.fill();
    ctx.restore();

    // aim reticle
    ctx.strokeStyle = 'rgba(255,255,255,0.65)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(state.aim.x, state.aim.y, 12, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(state.aim.x-18, state.aim.y);
    ctx.lineTo(state.aim.x-8, state.aim.y);
    ctx.moveTo(state.aim.x+8, state.aim.y);
    ctx.lineTo(state.aim.x+18, state.aim.y);
    ctx.moveTo(state.aim.x, state.aim.y-18);
    ctx.lineTo(state.aim.x, state.aim.y-8);
    ctx.moveTo(state.aim.x, state.aim.y+8);
    ctx.lineTo(state.aim.x, state.aim.y+18);
    ctx.stroke();

    // targets
    for (const t of targets) {
      // body
      ctx.fillStyle = t.type.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, t.r, 0, Math.PI*2);
      ctx.fill();

      // face
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.beginPath();
      ctx.arc(t.x-5, t.y-2, 2.3, 0, Math.PI*2);
      ctx.arc(t.x+5, t.y-2, 2.3, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.beginPath();
      ctx.arc(t.x, t.y+5, 6, 0, Math.PI);
      ctx.stroke();

      // HP bar
      const bw = 34, bh = 6;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      roundRect(ctx, t.x-bw/2, t.y-t.r-14, bw, bh, 4);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      roundRect(ctx, t.x-bw/2+1, t.y-t.r-13, (bw-2)*clamp(t.hp/t.maxHp,0,1), bh-2, 3);
      ctx.fill();
    }

    // bullets
    for (const b of bullets) {
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // particles
    for (const p of particles) {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }

    // top-left ammo
    ctx.fillStyle = 'rgba(255,255,255,0.82)';
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    const reloading = performance.now() < state.reloadAt;
    ctx.fillText(`Ammo: ${state.ammo}/${state.maxAmmo}${reloading ? ' (reloading…)': ''}`, 14, 22);

    if (state.paused) {
      centerText('PAUSED', h*0.42);
      centerText('Press P to resume', h*0.48, 14, 'rgba(255,255,255,0.75)');
    }
    if (state.gameOver) {
      centerText('GAME OVER', h*0.40);
      centerText('Click Reset to play again', h*0.47, 14, 'rgba(255,255,255,0.75)');
    }

    ctx.restore();
  }

  function centerText(txt, y, size=26, color='rgba(255,255,255,0.92)') {
    const w = canvas.getBoundingClientRect().width;
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${size}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(txt, w/2, y);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt, now);
    draw(now);
    requestAnimationFrame(loop);
  }

  // boot
  sidePanel.style.display = shopOpen ? 'block' : 'none';
  resize();
  renderShop();
  syncUI();
  toast('Pop Targets!');
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
